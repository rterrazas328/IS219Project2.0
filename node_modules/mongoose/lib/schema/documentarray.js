<<<<<<< HEAD
/* eslint no-empty: 1 */
=======
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

/*!
 * Module dependencies.
 */

var ArrayType = require('./array');
<<<<<<< HEAD
var CastError = require('../error/cast');
=======
var Document = require('../document');
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
var MongooseDocumentArray = require('../types/documentarray');
var SchemaType = require('../schematype');
var Subdocument = require('../types/embedded');

/**
 * SubdocsArray SchemaType constructor
 *
 * @param {String} key
 * @param {Schema} schema
 * @param {Object} options
 * @inherits SchemaArray
<<<<<<< HEAD
 * @api public
 */

function DocumentArray(key, schema, options) {
  // compile an embedded document for this schema
  function EmbeddedDocument() {
    Subdocument.apply(this, arguments);
  }

  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);
=======
 * @api private
 */

function DocumentArray (key, schema, options) {

  // compile an embedded document for this schema
  function EmbeddedDocument () {
    Subdocument.apply(this, arguments);
  }

  EmbeddedDocument.prototype.__proto__ = Subdocument.prototype;
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
  EmbeddedDocument.prototype.$__setSchema(schema);
  EmbeddedDocument.schema = schema;

  // apply methods
<<<<<<< HEAD
  for (var i in schema.methods)
    EmbeddedDocument.prototype[i] = schema.methods[i];

  // apply statics
  for (i in schema.statics)
    EmbeddedDocument[i] = schema.statics[i];

  EmbeddedDocument.options = options;
=======
  for (var i in schema.methods) {
    EmbeddedDocument.prototype[i] = schema.methods[i];
  }

  // apply statics
  for (var i in schema.statics)
    EmbeddedDocument[i] = schema.statics[i];

  EmbeddedDocument.options = options;
  this.schema = schema;
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

  ArrayType.call(this, key, EmbeddedDocument, options);

  this.schema = schema;
  var path = this.path;
  var fn = this.defaultValue;

<<<<<<< HEAD
  this.default(function() {
=======
  this.default(function(){
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
    var arr = fn.call(this);
    if (!Array.isArray(arr)) arr = [arr];
    return new MongooseDocumentArray(arr, path, this);
  });
<<<<<<< HEAD
}

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
DocumentArray.schemaName = 'DocumentArray';
=======
};
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

/*!
 * Inherits from ArrayType.
 */
<<<<<<< HEAD
DocumentArray.prototype = Object.create( ArrayType.prototype );
DocumentArray.prototype.constructor = DocumentArray;
=======

DocumentArray.prototype.__proto__ = ArrayType.prototype;
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

/**
 * Performs local validations first, then validations on each embedded doc
 *
 * @api private
 */

<<<<<<< HEAD
DocumentArray.prototype.doValidate = function(array, fn, scope, options) {
  SchemaType.prototype.doValidate.call(this, array, function(err) {
    if (err) {
      return fn(err);
    }

    var count = array && array.length;
    var error;

    if (!count) {
      return fn();
    }
    if (options && options.updateValidator) {
      return fn();
    }
=======
DocumentArray.prototype.doValidate = function (array, fn, scope) {
  var self = this;

  SchemaType.prototype.doValidate.call(this, array, function (err) {
    if (err) return fn(err);

    var count = array && array.length
      , error;

    if (!count) return fn();
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

    // handle sparse arrays, do not use array.forEach which does not
    // iterate over sparse elements yet reports array.length including
    // them :(

    for (var i = 0, len = count; i < len; ++i) {
      // sidestep sparse entries
      var doc = array[i];
      if (!doc) {
<<<<<<< HEAD
        --count || fn(error);
        continue;
      }

      doc.validate({ __noPromise: true }, function(err) {
        if (err) {
          error = err;
        }
        --count || fn(error);
      });
=======
        --count || fn();
        continue;
      }

      ;(function (i) {
        doc.validate(function (err) {
          if (err && !error) {
            // rewrite the key
            err.key = self.key + '.' + i + '.' + err.key;
            return fn(error = err);
          }
          --count || fn();
        });
      })(i);
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
    }
  }, scope);
};

/**
<<<<<<< HEAD
 * Performs local validations first, then validations on each embedded doc.
 *
 * ####Note:
 *
 * This method ignores the asynchronous validators.
 *
 * @return {MongooseError|undefined}
 * @api private
 */

DocumentArray.prototype.doValidateSync = function(array, scope) {
  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
  if (schemaTypeError) return schemaTypeError;

  var count = array && array.length,
      resultError = null;

  if (!count) {
    return;
  }

  // handle sparse arrays, do not use array.forEach which does not
  // iterate over sparse elements yet reports array.length including
  // them :(

  for (var i = 0, len = count; i < len; ++i) {
    // only first error
    if ( resultError ) break;
    // sidestep sparse entries
    var doc = array[i];
    if (!doc) continue;

    var subdocValidateError = doc.validateSync();

    if (subdocValidateError) {
      resultError = subdocValidateError;
    }
  }

  return resultError;
};

/**
=======
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
 * Casts contents
 *
 * @param {Object} value
 * @param {Document} document that triggers the casting
 * @api private
 */

<<<<<<< HEAD
DocumentArray.prototype.cast = function(value, doc, init, prev) {
  var selected,
      subdoc,
      i;
=======
DocumentArray.prototype.cast = function (value, doc, init, prev) {
  var selected
    , subdoc
    , i
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

  if (!Array.isArray(value)) {
    // gh-2442 mark whole array as modified if we're initializing a doc from
    // the db and the path isn't an array in the document
    if (!!doc && init) {
      doc.markModified(this.path);
    }
    return this.cast([value], doc, init, prev);
  }

<<<<<<< HEAD
  if (!(value && value.isMongooseDocumentArray)) {
=======
  if (!(value instanceof MongooseDocumentArray)) {
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
    value = new MongooseDocumentArray(value, this.path, doc);
    if (prev && prev._handlers) {
      for (var key in prev._handlers) {
        doc.removeListener(key, prev._handlers[key]);
      }
    }
  }

  i = value.length;

  while (i--) {
<<<<<<< HEAD
    if (!value[i]) {
      continue;
    }
    // Check if the document has a different schema (re gh-3701)
    if ((value[i] instanceof Subdocument) &&
        value[i].schema !== this.casterConstructor.schema) {
      value[i] = value[i].toObject({ virtuals: false });
    }
    if (!(value[i] instanceof Subdocument) && value[i]) {
      if (init) {
        selected || (selected = scopePaths(this, doc.$__.selected, init));
        subdoc = new this.casterConstructor(null, value, true, selected, i);
=======
    if (!(value[i] instanceof Subdocument) && value[i]) {
      if (init) {
        selected || (selected = scopePaths(this, doc.$__.selected, init));
        subdoc = new this.casterConstructor(null, value, true, selected);
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
        value[i] = subdoc.init(value[i]);
      } else {
        try {
          subdoc = prev.id(value[i]._id);
<<<<<<< HEAD
        } catch (e) {}
=======
        } catch(e) {}
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

        if (prev && subdoc) {
          // handle resetting doc with existing id but differing data
          // doc.array = [{ doc: 'val' }]
          subdoc.set(value[i]);
<<<<<<< HEAD
          // if set() is hooked it will have no return value
          // see gh-746
          value[i] = subdoc;
        } else {
          try {
            subdoc = new this.casterConstructor(value[i], value, undefined,
              undefined, i);
            // if set() is hooked it will have no return value
            // see gh-746
            value[i] = subdoc;
          } catch (error) {
            throw new CastError('embedded', value[i], value._path);
          }
        }
=======
        } else {
          subdoc = new this.casterConstructor(value[i], value);
        }

        // if set() is hooked it will have no return value
        // see gh-746
        value[i] = subdoc;
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83
      }
    }
  }

  return value;
<<<<<<< HEAD
};
=======
}
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

/*!
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param {DocumentArray} array - the array to scope `fields` paths
 * @param {Object|undefined} fields - the root fields selected in the query
 * @param {Boolean|undefined} init - if we are being created part of a query result
 */

<<<<<<< HEAD
function scopePaths(array, fields, init) {
  if (!(init && fields)) return undefined;

  var path = array.path + '.',
      keys = Object.keys(fields),
      i = keys.length,
      selected = {},
      hasKeys,
      key;
=======
function scopePaths (array, fields, init) {
  if (!(init && fields)) return undefined;

  var path = array.path + '.'
    , keys = Object.keys(fields)
    , i = keys.length
    , selected = {}
    , hasKeys
    , key
>>>>>>> 923637243c51b35e8862bfced9d2f31719759a83

  while (i--) {
    key = keys[i];
    if (0 === key.indexOf(path)) {
      hasKeys || (hasKeys = true);
      selected[key.substring(path.length)] = fields[key];
    }
  }

  return hasKeys && selected || undefined;
}

/*!
 * Module exports.
 */

module.exports = DocumentArray;
